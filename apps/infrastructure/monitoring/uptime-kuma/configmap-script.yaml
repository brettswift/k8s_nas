apiVersion: v1
kind: ConfigMap
metadata:
  name: uptime-kuma-sync-script
  namespace: monitoring
  labels:
    app: uptime-kuma-sync
data:
  sync-monitors.sh: |
    #!/bin/bash
    # Sync Kubernetes Ingress resources to Uptime Kuma monitors
    # This script queries ingresses with the uptime-kuma.monitor/enabled annotation
    # and creates/updates monitors in Uptime Kuma via API

    set -euo pipefail

    # Configuration
    UPTIME_KUMA_URL="${UPTIME_KUMA_URL:-http://uptime-kuma.monitoring.svc.cluster.local:3001}"
    UPTIME_KUMA_API_KEY="${UPTIME_KUMA_API_KEY:-}"
    NAMESPACES="${NAMESPACES:-media homeautomation qbittorrent homepage}"
    ANNOTATION_ENABLED="uptime-kuma.monitor/enabled"
    ANNOTATION_NOTIFICATIONS="uptime-kuma.monitor/notifications"
    ANNOTATION_NAME="uptime-kuma.monitor/name"

    # Colors for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color

    log_info() {
        echo -e "${GREEN}[INFO]${NC} $1"
    }

    log_warn() {
        echo -e "${YELLOW}[WARN]${NC} $1"
    }

    log_error() {
        echo -e "${RED}[ERROR]${NC} $1"
    }

    # Check if API key is set
    if [ -z "$UPTIME_KUMA_API_KEY" ]; then
        log_error "UPTIME_KUMA_API_KEY environment variable is not set"
        exit 1
    fi

    # Function to get all monitors from Uptime Kuma
    get_all_monitors() {
        local response=$(curl -s -X GET \
            -H "Authorization: Bearer ${UPTIME_KUMA_API_KEY}" \
            -H "Content-Type: application/json" \
            "${UPTIME_KUMA_URL}/api/monitors" 2>/dev/null)
        
        # Debug: log first 100 chars of response
        if echo "$response" | grep -q "<!DOCTYPE html>"; then
            log_error "API returned HTML instead of JSON. Check API key and endpoint."
            log_error "Response preview: $(echo "$response" | head -c 100)"
            echo ""
            return 1
        fi
        
        # Check if response is valid JSON array
        if echo "$response" | jq -e '. | type == "array"' >/dev/null 2>&1; then
            echo "$response" | jq -r '.[] | "\(.id)|\(.name)|\(.url)"' 2>/dev/null || echo ""
        else
            log_warn "Failed to fetch monitors or invalid response: $(echo "$response" | head -c 200)"
            echo ""
        fi
    }

    # Function to create or update a monitor
    upsert_monitor() {
        local monitor_name=$1
        local monitor_url=$2
        local enable_notifications=$3
        local monitor_id=$4

        local json_payload
        if [ -n "$monitor_id" ]; then
            # Update existing monitor
            json_payload=$(jq -n \
                --arg name "$monitor_name" \
                --arg url "$monitor_url" \
                --argjson notifications "$enable_notifications" \
                '{
                    name: $name,
                    url: $url,
                    type: "http",
                    interval: 60,
                    retryInterval: 60,
                    maxretries: 1,
                    notify: $notifications
                }')
            
            log_info "Updating monitor: $monitor_name ($monitor_id)"
            local result=$(curl -s -w "\n%{http_code}" -X PUT \
                -H "Authorization: Bearer ${UPTIME_KUMA_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "$json_payload" \
                "${UPTIME_KUMA_URL}/api/monitors/${monitor_id}")
            local http_code=$(echo "$result" | tail -1)
            if [ "$http_code" != "200" ] && [ "$http_code" != "201" ]; then
                log_error "Failed to update monitor: HTTP $http_code"
            fi
        else
            # Create new monitor
            json_payload=$(jq -n \
                --arg name "$monitor_name" \
                --arg url "$monitor_url" \
                --argjson notifications "$enable_notifications" \
                '{
                    name: $name,
                    url: $url,
                    type: "http",
                    interval: 60,
                    retryInterval: 60,
                    maxretries: 1,
                    notify: $notifications
                }')
            
            log_info "Creating monitor: $monitor_name"
            local result=$(curl -s -w "\n%{http_code}" -X POST \
                -H "Authorization: Bearer ${UPTIME_KUMA_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "$json_payload" \
                "${UPTIME_KUMA_URL}/api/monitors")
            local http_code=$(echo "$result" | tail -1)
            if [ "$http_code" != "200" ] && [ "$http_code" != "201" ]; then
                log_error "Failed to create monitor: HTTP $http_code - Response: $(echo "$result" | head -n -1)"
            else
                log_info "Monitor created successfully"
            fi
        fi
    }

    # Function to delete a monitor
    delete_monitor() {
        local monitor_id=$1
        local monitor_name=$2
        
        log_info "Deleting monitor: $monitor_name ($monitor_id)"
        curl -s -X DELETE \
            -H "Authorization: Bearer ${UPTIME_KUMA_API_KEY}" \
            "${UPTIME_KUMA_URL}/api/monitors/${monitor_id}" > /dev/null
    }

    # Function to build URL from ingress
    build_url_from_ingress() {
        local ingress_json=$1
        
        # Get the first host and path
        local host=$(echo "$ingress_json" | jq -r '.spec.rules[0].host // empty')
        local path=$(echo "$ingress_json" | jq -r '.spec.rules[0].http.paths[0].path // "/"')
        
        # Check if TLS is configured
        local has_tls=$(echo "$ingress_json" | jq -r '.spec.tls // [] | length > 0')
        
        # Build URL
        local protocol="http"
        if [ "$has_tls" = "true" ]; then
            protocol="https"
        fi
        
        # Normalize path (ensure it starts with /)
        if [ "$path" = "null" ] || [ -z "$path" ]; then
            path="/"
        fi
        
        # Remove trailing slash for consistency (except root)
        if [ "$path" != "/" ] && [[ "$path" == */ ]]; then
            path="${path%/}"
        fi
        
        echo "${protocol}://${host}${path}"
    }

    # Main sync logic
    main() {
        log_info "Starting Uptime Kuma monitor sync..."
        log_info "Uptime Kuma URL: $UPTIME_KUMA_URL"
        
        # Get all existing monitors and create a lookup map
        declare -A existing_monitors
        while IFS='|' read -r id name url; do
            if [ -n "$id" ] && [ -n "$name" ]; then
                existing_monitors["$name"]="$id|$url"
            fi
        done < <(get_all_monitors)
        
        # Track which monitors we've processed
        declare -A processed_monitors
        
        # Query ingresses in specified namespaces
        for namespace in $NAMESPACES; do
            log_info "Processing namespace: $namespace"
            
            # Get all ingresses in the namespace
            ingresses=$(kubectl get ingress -n "$namespace" -o json 2>/dev/null || echo '{"items":[]}')
            
            # Process each ingress
            echo "$ingresses" | jq -r '.items[] | @base64' | while IFS= read -r ingress_b64; do
                ingress_json=$(echo "$ingress_b64" | base64 -d)
                
                # Check if monitoring is enabled
                enabled=$(echo "$ingress_json" | jq -r ".metadata.annotations.\"${ANNOTATION_ENABLED}\" // \"false\"")
                
                if [ "$enabled" != "true" ]; then
                    continue
                fi
                
                # Get monitor name (use annotation or default to ingress name)
                monitor_name=$(echo "$ingress_json" | jq -r ".metadata.annotations.\"${ANNOTATION_NAME}\" // .metadata.name")
                namespace_name=$(echo "$ingress_json" | jq -r '.metadata.namespace')
                full_monitor_name="${namespace_name}/${monitor_name}"
                
                # Get notification preference
                enable_notifications=$(echo "$ingress_json" | jq -r ".metadata.annotations.\"${ANNOTATION_NOTIFICATIONS}\" // \"false\"")
                if [ "$enable_notifications" = "true" ]; then
                    enable_notifications="true"
                else
                    enable_notifications="false"
                fi
                
                # Build URL from ingress
                monitor_url=$(build_url_from_ingress "$ingress_json")
                
                if [ -z "$monitor_url" ] || [ "$monitor_url" = "null" ]; then
                    log_warn "Skipping ${full_monitor_name}: Could not build URL"
                    continue
                fi
                
                log_info "Processing: ${full_monitor_name} -> ${monitor_url}"
                
                # Check if monitor already exists
                monitor_id=""
                if [ -n "${existing_monitors[$full_monitor_name]:-}" ]; then
                    monitor_id=$(echo "${existing_monitors[$full_monitor_name]}" | cut -d'|' -f1)
                fi
                
                # Create or update monitor
                upsert_monitor "$full_monitor_name" "$monitor_url" "$enable_notifications" "$monitor_id"
                
                # Mark as processed
                processed_monitors["$full_monitor_name"]=1
            done
        done
        
        # Delete monitors that no longer have the annotation
        log_info "Checking for monitors to remove..."
        for monitor_name in "${!existing_monitors[@]}"; do
            # Check if this monitor name matches our namespace pattern
            if [[ "$monitor_name" =~ ^(media|homeautomation|qbittorrent|homepage)/ ]]; then
                # Check if we processed this monitor
                if [ -z "${processed_monitors[$monitor_name]:-}" ]; then
                    monitor_id=$(echo "${existing_monitors[$monitor_name]}" | cut -d'|' -f1)
                    delete_monitor "$monitor_id" "$monitor_name"
                fi
            fi
        done
        
        log_info "Monitor sync completed!"
    }

    # Run main function
    main

