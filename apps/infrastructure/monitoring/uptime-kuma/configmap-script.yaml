apiVersion: v1
kind: ConfigMap
metadata:
  name: uptime-kuma-sync-python-script
  namespace: monitoring
  labels:
    app: uptime-kuma-sync
data:
  sync-monitors.py: |
    #!/usr/bin/env python3
    """
    Uptime Kuma Monitor Sync using Socket.IO directly
    This script syncs Kubernetes ingresses to Uptime Kuma monitors
    """

    import os
    import sys
    import json
    import subprocess
    import time
    from typing import Dict, List, Optional

    try:
        import socketio
    except ImportError:
        print("[ERROR] python-socketio library not installed")
        sys.exit(1)

    # Configuration
    UPTIME_KUMA_URL = os.environ.get('UPTIME_KUMA_URL', 'http://uptime-kuma.monitoring.svc.cluster.local:3001')
    UPTIME_KUMA_USERNAME = os.environ.get('UPTIME_KUMA_USERNAME', 'admin')
    UPTIME_KUMA_PASSWORD = os.environ.get('UPTIME_KUMA_PASSWORD', '')
    NAMESPACES = os.environ.get('NAMESPACES', 'media homeautomation qbittorrent homepage').split()

    ANNOTATION_ENABLED = 'uptime-kuma.monitor/enabled'
    ANNOTATION_NOTIFICATIONS = 'uptime-kuma.monitor/notifications'
    ANNOTATION_NAME = 'uptime-kuma.monitor/name'
    ANNOTATION_HEALTHCHECK_PATH = 'uptime-kuma.monitor/healthcheck-path'

    def log_info(msg: str):
        print(f"[INFO] {msg}")

    def log_warn(msg: str):
        print(f"[WARN] {msg}")

    def log_error(msg: str):
        print(f"[ERROR] {msg}")

    def kubectl_get_ingresses(namespace: str) -> List[Dict]:
        """Get all ingresses from a namespace"""
        try:
            result = subprocess.run(
                ['kubectl', 'get', 'ingress', '-n', namespace, '-o', 'json'],
                capture_output=True,
                text=True,
                check=True
            )
            data = json.loads(result.stdout)
            return data.get('items', [])
        except subprocess.CalledProcessError:
            return []
        except json.JSONDecodeError:
            return []

    def build_url_from_ingress(ingress: Dict) -> Optional[str]:
        """Build URL from ingress spec"""
        try:
            rules = ingress.get('spec', {}).get('rules', [])
            if not rules:
                return None
            
            host = rules[0].get('host', '')
            paths = rules[0].get('http', {}).get('paths', [])
            path = paths[0].get('path', '/') if paths else '/'
            
            # Check for healthcheck path annotation
            annotations = ingress.get('metadata', {}).get('annotations', {})
            healthcheck_path = annotations.get(ANNOTATION_HEALTHCHECK_PATH, '')
            
            # Use healthcheck path if specified, otherwise use ingress path
            if healthcheck_path:
                # Healthcheck path is always absolute (starts with /)
                # Use it directly, replacing the ingress path
                path = healthcheck_path
            else:
                # Normalize path - remove regex patterns like (.*)
                if path and '(' in path:
                    # Extract the base path before regex
                    path = path.split('(')[0].rstrip('/')
                
                # Normalize path
                if path == 'null' or not path:
                    path = '/'
                if path != '/' and path.endswith('/'):
                    path = path.rstrip('/')
            
            # Check if TLS is configured
            tls = ingress.get('spec', {}).get('tls', [])
            protocol = 'https' if tls else 'http'
            
            return f"{protocol}://{host}{path}"
        except Exception as e:
            log_error(f"Error building URL: {e}")
            return None

    def main():
        log_info("Starting Uptime Kuma monitor sync...")
        log_info(f"Uptime Kuma URL: {UPTIME_KUMA_URL}")
        
        if not UPTIME_KUMA_PASSWORD:
            log_error("UPTIME_KUMA_PASSWORD environment variable is not set")
            sys.exit(1)
        
        # Initialize Socket.IO client
        sio = socketio.Client()
        login_success = False
        
        # Connect to Uptime Kuma
        try:
            log_info("Connecting to Uptime Kuma via Socket.IO...")
            sio.connect(UPTIME_KUMA_URL)
            log_info("Connected to Uptime Kuma")
            
            # Login
            log_info("Authenticating...")
            login_response = sio.call('login', {
                'username': UPTIME_KUMA_USERNAME,
                'password': UPTIME_KUMA_PASSWORD
            }, timeout=10)
            
            if login_response and login_response.get('ok'):
                log_info("Successfully logged in to Uptime Kuma")
                login_success = True
            else:
                error_msg = login_response.get('msg', 'Unknown error') if login_response else 'No response'
                log_error(f"Login failed: {error_msg}")
                sys.exit(1)
        except Exception as e:
            log_error(f"Failed to connect/login to Uptime Kuma: {e}")
            import traceback
            log_error(traceback.format_exc())
            sys.exit(1)
        
        if not login_success:
            log_error("Login was not successful")
            sys.exit(1)
        
        # Get existing monitors
        try:
            log_info("Fetching existing monitors...")
            monitors_response = sio.call('getMonitors', timeout=10)
            if monitors_response and monitors_response.get('ok'):
                existing_monitors_list = monitors_response.get('monitors', [])
                existing_monitors = {m.get('name', ''): m for m in existing_monitors_list if m.get('name')}
                log_info(f"Found {len(existing_monitors)} existing monitors")
            else:
                log_warn("Failed to get monitors response, assuming no monitors exist")
                existing_monitors = {}
        except Exception as e:
            log_error(f"Failed to fetch monitors: {e}")
            import traceback
            log_error(traceback.format_exc())
            existing_monitors = {}
        
        processed_monitors = set()
        
        # Process ingresses
        for namespace in NAMESPACES:
            log_info(f"Processing namespace: {namespace}")
            ingresses = kubectl_get_ingresses(namespace)
            log_info(f"Found {len(ingresses)} ingresses in namespace {namespace}")
            
            for ingress in ingresses:
                annotations = ingress.get('metadata', {}).get('annotations', {})
                enabled = annotations.get(ANNOTATION_ENABLED, 'false')
                
                ingress_name = ingress.get('metadata', {}).get('name', '')
                log_info(f"Checking ingress: {namespace}/{ingress_name} - enabled: {enabled}")
                
                if enabled != 'true':
                    continue
                
                # Get monitor name
                monitor_name = annotations.get(ANNOTATION_NAME, ingress_name)
                full_monitor_name = f"{namespace}/{monitor_name}"
                
                # Get notification preference
                enable_notifications = annotations.get(ANNOTATION_NOTIFICATIONS, 'false') == 'true'
                
                # Build URL
                monitor_url = build_url_from_ingress(ingress)
                if not monitor_url:
                    log_warn(f"Skipping {full_monitor_name}: Could not build URL")
                    continue
                
                log_info(f"Processing: {full_monitor_name} -> {monitor_url}")
                
                # Check if monitor exists
                monitor_id = None
                if full_monitor_name in existing_monitors:
                    monitor_id = existing_monitors[full_monitor_name].get('id')
                    log_info(f"Updating monitor: {full_monitor_name} ({monitor_id})")
                else:
                    log_info(f"Creating monitor: {full_monitor_name}")
                
                # Prepare monitor data
                # Uptime Kuma 2.0.2 requires conditions field as JSON string
                # Format: "[{\"every\": true, \"conditions\": []}]" - condition group with 'every' property
                monitor_data = {
                    'name': full_monitor_name,
                    'url': monitor_url,
                    'type': 'http',
                    'interval': 60,
                    'retryInterval': 60,
                    'maxretries': 1,
                    'conditions': json.dumps([{"every": True, "conditions": []}])  # Empty condition group for 2.0.2
                }
                
                # Add notification settings if needed
                if enable_notifications:
                    monitor_data['notify'] = True
                
                # Create or update
                try:
                    if monitor_id:
                        # Update existing monitor
                        monitor_data['id'] = monitor_id
                        response = sio.call('editMonitor', monitor_data, timeout=10)
                        if response and response.get('ok'):
                            log_info(f"Monitor updated successfully: {full_monitor_name}")
                        else:
                            error_msg = response.get('msg', 'Unknown error') if response else 'No response'
                            raise Exception(f"Update failed: {error_msg}")
                    else:
                        # Create new monitor
                        response = sio.call('addMonitor', monitor_data, timeout=10)
                        if response and response.get('ok'):
                            log_info(f"Monitor created successfully: {full_monitor_name}")
                        else:
                            error_msg = response.get('msg', 'Unknown error') if response else 'No response'
                            raise Exception(f"Create failed: {error_msg}")
                except Exception as e:
                    log_error(f"Failed to {'update' if monitor_id else 'create'} monitor: {full_monitor_name} - {e}")
                    import traceback
                    log_error(traceback.format_exc())
                
                processed_monitors.add(full_monitor_name)
        
        # Remove monitors that no longer have the annotation
        log_info("Checking for monitors to remove...")
        for monitor_name, monitor_info in existing_monitors.items():
            if monitor_name.startswith(tuple(f"{ns}/" for ns in NAMESPACES)):
                if monitor_name not in processed_monitors:
                    monitor_id = monitor_info.get('id')
                    log_info(f"Deleting monitor: {monitor_name} ({monitor_id})")
                    try:
                        response = sio.call('deleteMonitor', {'id': monitor_id}, timeout=10)
                        if response and response.get('ok'):
                            log_info(f"Monitor deleted successfully: {monitor_name}")
                        else:
                            error_msg = response.get('msg', 'Unknown error') if response else 'No response'
                            log_error(f"Failed to delete monitor: {monitor_name} - {error_msg}")
                    except Exception as e:
                        log_error(f"Failed to delete monitor: {monitor_name} - {e}")
        
        # Disconnect
        try:
            sio.disconnect()
            log_info("Disconnected from Uptime Kuma")
        except:
            pass
        
        log_info("Monitor sync completed!")

    if __name__ == '__main__':
        main()
